# Domain Knowledge Matters: Improving Prompts with Fix Templates for Repairing Python Type Errors

- International Conference on Software Engineering 2024

- [paper](https://arxiv.org/pdf/2306.01394)

- Qwen2.5 & ChatGPT4o

- [x] 人工修正

## 动机

*本文旨在*解决Python动态类型系统带来的运行时类型错误问题。虽然动态类型方便了编程，但也带来了难以修复的类型错误。现有的基于规则的方法在模板覆盖面上有限，而学习方法虽然减轻了设计修补合成规则的手动工作，但在处理特定领域知识时仍存在局限性。因此，作者提出了一个名为TypeFix的新方法，旨在通过结合领域知识和预训练模型来提高自动修复Python类型错误的效果。

## 创新点

1. 提出了TypeFix，这是首个针对Python类型错误修复的领域感知提示方法。
2. 设计了一种新的修复模板，可以处理不同级别的类型错误，并且通过一种新颖的层次聚类算法从已有的类型错误修复中挖掘各种修复模板。
3. 实验表明，TypeFix在修复Python类型错误方面比最新的基于规则和学习的方法更有效，并且挖掘出的修复模板具有很高的覆盖率。

## 与现有方法的区别

相较于基于规则的方法，TypeFix不需要手动定义模板或修补合成规则，而是通过自动化的模板挖掘过程来实现。
与学习方法相比，TypeFix将领域知识融入代码提示中，通过应用修复模板到有缺陷的代码中，调用预训练的代码模型生成候选补丁，从而提高了修复的针对性和准确性。

## 详细方法

论文介绍了一种名为TypeFix的修复Python类型错误的方法，分为两个主要阶段：模板挖掘阶段和补丁生成阶段。以下是该方法的具体实现过程：

首先，模板挖掘阶段：
修复解析：TypeFix首先解析已存在的类型错误修复，提取特定修复模板。它通过遍历错误和修复代码的抽象语法树（AST）来生成修复模式。TypeFix识别错误代码和修复代码中的变化并创建“修复模式”，这些模式表示如何从错误代码变为修复代码。

修复模板的定义与生成：修复模板由修复模式、内部上下文和外部上下文组成。内部上下文是错误所在语句的剩余部分，而外部上下文则提供额外的位置信息，用于处理代码中相应的修改。在此过程中，TypeFix采用分层聚类算法，将具体的修复模板抽象并合并为更通用的修复模板。

层次化聚类与模板抽象：TypeFix通过定义值距离和结构距离来度量修复模板的相似性。使用这些度量，TypeFix不断抽象和合并相似的修复模板，将其组织为聚类树。修复模板的抽象按优先级顺序处理，外部上下文优先于内部上下文，再优先于修复模式。

然后，补丁生成阶段：
匹配修复模板：TypeFix通过广度优先搜索（BFS）匹配聚类树中的修复模板，找到最适合待修复程序的模板。TypeFix根据修复模板的实例数和抽象比率对匹配到的修复模板进行排序。实例数越多表示该模板适用于更多错误，而较低的抽象比率意味着修复模板包含更多领域知识，因此优先使用。

应用修复模板：TypeFix将修复模板应用到待修复代码中，将模板中的“空白”节点插入到代码的相应位置。这些“空白”节点作为预测修复的占位符，代码会被转换为包含这些占位符的代码提示。

生成候选补丁：TypeFix使用代码预训练模型（如CodeT5）生成候选补丁。它根据代码提示预测占位符的值，并将这些预测结果填入代码提示，生成最终的修复代码。

验证补丁：TypeFix通过经典的生成-验证方法，过滤掉有语法错误的补丁，并使用测试套件验证候选补丁的正确性。那些通过所有测试用例的补丁会进一步由作者检查，确保它们与开发者的原始修复语义一致。

## 研究问题

- **RQ1.** TypeFix修复类型错误的有效性如何？
- **RQ2.** TypeFix挖掘修复模板的能力如何？
- **RQ3.** TypeFix在什么情况下无法修复类型错误？

### 评价指标

采用了以往工作中常用的Correct和Plausible指标来评估TypeFix在修复类型错误方面的性能。此外，还增加了一个名为Template Coverage的新指标，用于评估由TypeFix挖掘的修复模板以及PyTER预定义模板所覆盖的开发者补丁数量。Template Coverage定义为开发者补丁与某种方法的修复模板匹配的错误比例。

### 每个研究问题的结果

**RQ1.** 在两个基准测试集TypeBugs和BugsInPy上评估了TypeFix与最新基于规则和学习方法的对比性能。实验结果显示，TypeFix在这两个基准测试集中分别修复了55个和26个类型错误，优于其他方法。

**RQ2.** 通过分析TypeFix挖掘的修复模板是否能覆盖实际存在的类型错误，实验发现TypeFix挖掘的修复模板能够覆盖约75%的类型错误，远高于其他方法。

**RQ3.** 分析了TypeFix未能修复类型错误的情况，可能是因为某些类型的错误超出了当前修复模板的范围，或者需要更复杂的逻辑才能正确修复。

## 有效性威胁

虽然TypeFix在大多数情况下表现良好，但对于非常规或复杂类型的类型错误，其修复能力可能会受到限制。挖掘的修复模板可能不完全适用于所有类型的类型错误，这可能导致某些错误无法被有效修复。